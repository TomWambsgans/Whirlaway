/*

This file is automatically generated for each sumcheck type.

*/

#include <stdio.h>
#include <stdint.h>
#include "../../ff_wrapper.cu"

#define LOG_WARP_SIZE 5 // cuda warp = 32 threads

#if CACHED
#define NODE(i) node_##i
#else
#define NODE(i) multilinears[i][hypercube_point]
#endif

// TODO avoid embedding overhead in the first round
extern "C" __global__ void compute_over_hypercube(Field_B **multilinears, // Each multilinears has size 2^n_vars
                                                  Field_C *sums,          // sums has size 2^n_vars
                                                  Field_C *batching_scalars,
                                                  uint32_t n_vars,
                                                  uint32_t compute_unit_start,
                                                  uint32_t local_compute_units_count,
                                                  uint32_t total_compute_units_count)
{
    // to obtain synchronized threads at warp level
    // (this requires to launch the kernel with `warp_shift` more threads than required without warp consideration)
    const int warp_shift = max(0, LOG_WARP_SIZE - int(n_vars));

    const int n_total_threads = gridDim.x * blockDim.x;
    const int total_computations = local_compute_units_count << max(LOG_WARP_SIZE, n_vars);
    const int n_reps = (total_computations + n_total_threads - 1) / n_total_threads;

    for (int rep = 0; rep < n_reps; rep++)
    {
        int thread_index = threadIdx.x + (blockIdx.x + rep * gridDim.x) * blockDim.x;
        if (thread_index >= total_computations || thread_index % (1 << warp_shift) != 0)
            continue;
        thread_index /= (1 << warp_shift);

        const int hypercube_point = thread_index % (1 << n_vars);
        const int compute_unit_index = compute_unit_start + thread_index / (1 << n_vars);
        const int target_sum_index = hypercube_point + compute_unit_index * (1 << n_vars);

        switch (compute_unit_index)
        {
            // AUTOMATICALLY GENERATED
            COMPOSITION_PLACEHOLDER
        }
    }
}
